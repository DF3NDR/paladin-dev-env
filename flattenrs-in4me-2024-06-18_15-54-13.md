## src/application/mod.rs
```rust
pub mod use_cases;
```

## src/application/use_cases/mod.rs
```rust
pub mod fetch_content;
pub mod analyze_content;
pub mod aggregate_content;
pub mod deliver_content;

```

## src/application/use_cases/aggregate_content.rs
```rust
use serde_json::Value;
use crate::domain::services::content_aggregation_service::ContentAggregationService;

pub struct AggregateContentUseCase<T: ContentAggregationService> {
    service: T,
}

impl<T: ContentAggregationService> AggregateContentUseCase<T> {
    pub fn new(service: T) -> Self {
        Self { service }
    }

    pub fn execute(&self, data: Vec<Value>) -> Value {
        self.service.aggregate_content(data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::Value;
    use crate::domain::services::content_aggregation_service::ContentAggregationService;

    struct MockContentAggregationService;

    impl ContentAggregationService for MockContentAggregationService {
        fn aggregate_content(&self, data: Vec<Value>) -> Value {
            Value::Array(data)
        }
    }

    #[test]
    fn test_aggregate_content() {
        let service = MockContentAggregationService;
        let use_case = AggregateContentUseCase::new(service);
        let data = vec![Value::String("Test Data".to_string())];
        let result = use_case.execute(data);
        assert_eq!(result, Value::Array(vec![Value::String("Test Data".to_string())]));
    }
}

```

## src/application/use_cases/fetch_content.rs
```rust
use crate::domain::services::content_fetching_service::ContentFetchingService;
use crate::domain::entities::normalized_data::NormalizedData;
pub struct FetchContentUseCase<T: ContentFetchingService> {
    service: T,
}

impl<T: ContentFetchingService> FetchContentUseCase<T> {
    pub fn new(service: T) -> Self {
        Self { service }
    }

    pub fn execute(&self, url: &str) -> Vec<NormalizedData> {
        self.service.fetch_content(url)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::entities::normalized_data::NormalizedData;
    use crate::domain::services::content_fetching_service::ContentFetchingService;

    struct MockContentFetchingService;

    impl ContentFetchingService for MockContentFetchingService {
        fn fetch_content(&self, _url: &str) -> Vec<NormalizedData> {
            vec![
                NormalizedData {
                    title: "Test Title".to_string(),
                    link: "http://example.com".to_string(),
                    description: "Test Description".to_string(),
                }
            ]
        }
    }

    #[test]
    fn test_fetch_content() {
        let service = MockContentFetchingService;
        let use_case = FetchContentUseCase::new(service);
        let result = use_case.execute("http://example.com");
        assert_eq!(result.len(), 1);
        assert_eq!(result[0].title, "Test Title");
    }
}

```

## src/application/use_cases/deliver_content.rs
```rust
use crate::domain::services::content_delivery_service::ContentDeliveryService;

pub struct DeliverContentUseCase<T: ContentDeliveryService> {
    service: T,
}

impl<T: ContentDeliveryService> DeliverContentUseCase<T> {
    pub fn new(service: T) -> Self {
        Self { service }
    }

    pub fn execute(&self, content: &str) -> Result<(), String> {
        self.service.deliver_content(content)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::services::content_delivery_service::ContentDeliveryService;

    struct MockContentDeliveryService;

    impl ContentDeliveryService for MockContentDeliveryService {
        fn deliver_content(&self, _content: &str) -> Result<(), String> {
            Ok(())
        }
    }

    #[test]
    fn test_deliver_content() {
        let service = MockContentDeliveryService;
        let use_case = DeliverContentUseCase::new(service);
        let result = use_case.execute("Test Content");
        assert!(result.is_ok());
    }
}


```

## src/application/use_cases/analyze_content.rs
```rust
use serde_json::Value;
use crate::domain::services::content_analysis_service::ContentAnalysisService;
use crate::domain::entities::normalized_data::NormalizedData;

pub struct AnalyzeContentUseCase<T: ContentAnalysisService> {
    service: T,
}

impl<T: ContentAnalysisService> AnalyzeContentUseCase<T> {
    pub fn new(service: T) -> Self {
        Self { service }
    }

    pub fn execute(&self, content: &NormalizedData) -> Result<Value, String> {
        self.service.analyze_content(content)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::services::content_analysis_service::ContentAnalysisService;
    use crate::domain::entities::normalized_data::NormalizedData;
    use serde_json::Value;

    struct MockContentAnalysisService;

    impl ContentAnalysisService for MockContentAnalysisService {
        fn analyze_content(&self, _content: &NormalizedData) -> Result<Value, String> {
            Ok(Value::String("Test Summary".to_string()))
        }
    }

    #[test]
    fn test_analyze_content() {
        let service = MockContentAnalysisService;
        let use_case = AnalyzeContentUseCase::new(service);
        let content = NormalizedData {
            title: "Test Title".to_string(),
            link: "http://example.com".to_string(),
            description: "Test Description".to_string(),
        };
        let result = use_case.execute(&content);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), Value::String("Test Summary".to_string()));
    }
}


```

## src/setup/use_case_initializer.rs
```rust
use std::sync::Arc;
use crate::adapters::primary::{
    http_content_fetcher::HttpContentFetcher,
    llm_content_analyzer::LlmContentAnalyzer,
    content_aggregator::ContentAggregator,
    http_content_deliverer::HttpContentDeliverer,
};
use crate::application::use_cases::{
    fetch_content::FetchContentUseCase,
    analyze_content::AnalyzeContentUseCase,
    aggregate_content::AggregateContentUseCase,
    deliver_content::DeliverContentUseCase,
};

#[derive(Clone)]
pub struct UseCases {
    pub fetch_content: Arc<FetchContentUseCase<HttpContentFetcher>>,
    pub analyze_content: Arc<AnalyzeContentUseCase<LlmContentAnalyzer>>,
    pub aggregate_content: Arc<AggregateContentUseCase<ContentAggregator>>,
    pub deliver_content: Arc<DeliverContentUseCase<HttpContentDeliverer>>,
}

pub fn initialize_use_cases() -> UseCases {
    let fetch_content = Arc::new(FetchContentUseCase::new(HttpContentFetcher {}));
    let analyze_content = Arc::new(AnalyzeContentUseCase::new(LlmContentAnalyzer {}));
    let aggregate_content = Arc::new(AggregateContentUseCase::new(ContentAggregator {}));
    let deliver_content = Arc::new(DeliverContentUseCase::new(HttpContentDeliverer {}));

    UseCases {
        fetch_content,
        analyze_content,
        aggregate_content,
        deliver_content,
    }
}

```

## src/setup/mod.rs
```rust
pub mod http_server;
pub mod service_runner;
pub mod use_case_initializer;

use crate::config::Settings;
use std::sync::Arc;

pub async fn setup_and_run(config: Settings) -> std::io::Result<()> {
    let config = Arc::new(config);
    let use_cases = use_case_initializer::initialize_use_cases();

    service_runner::run_services(config.clone(), use_cases.clone()).await;
    http_server::run_http_server(config, use_cases).await
}

```

## src/setup/http_server.rs
```rust
use std::sync::{Arc, Mutex};
use actix_web::{web, App, HttpServer};
use log::info;
use crate::config::Settings;
use crate::use_case_initializer::UseCases;

#[derive(Clone)]
pub struct AppState {
    pub summaries: Arc<Mutex<Vec<String>>>,
    pub use_cases: UseCases,
}

pub async fn run_http_server(config: Arc<Settings>, use_cases: UseCases) -> std::io::Result<()> {
    let app_state = web::Data::new(AppState {
        summaries: Arc::new(Mutex::new(Vec::new())),
        use_cases,
    });

    let server_config = config.server.clone();

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .app_data(web::Data::new(config.clone()))
            .configure(crate::adapters::primary::http_content_deliverer::configure)
    })
    .bind(format!("{}:{}", server_config.host, server_config.port))?
    .run()
    .await
}

```

## src/setup/service_runner.rs
```rust
use std::sync::Arc;
use crate::config::Settings;
use crate::infrastructure::repositories::sql_content_repository::SqlContentRepository;
use crate::infrastructure::notifications::email_notification_service::EmailNotificationService;
use tokio::task;
use crate::setup::use_case_initializer::UseCases;
use crate::adapters::primary::{scheduler::start_scheduler, queue::start_analyzer};

pub async fn run_services(config: Arc<Settings>, use_cases: UseCases) {
    // Initialize the database
    let _db = SqlContentRepository::init_db().expect("Failed to initialize database");

    // Initialize the email notification service
    let _email_service = EmailNotificationService::new();

    // Start the scheduler
    task::spawn(async move {
        start_scheduler().await;
    });

    // Start the analyzer
    task::spawn(async move {
        start_analyzer(config.clone()).await;
    });
}

```

## src/cli.rs
```rust
// src/cli.rs
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
#[structopt(name = "smartcontent-aggregator")]
pub struct Cli {
    #[structopt(short, long)]
    pub config: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cli_args() {
        let args = Cli::from_iter(&["smartcontent-aggregator", "--config", "config.yaml"]);
        assert_eq!(args.config, "config.yaml");
    }
}

```

## src/infrastructure/mod.rs
```rust
pub mod repositories;
pub mod external_apis;
pub mod notifications;

```

## src/infrastructure/external_apis/mod.rs
```rust
pub mod external_api_fetcher;

```

## src/infrastructure/external_apis/external_api_fetcher.rs
```rust
use crate::domain::entities::normalized_data::NormalizedData;
use crate::domain::services::content_fetching_service::ContentFetchingService;

pub struct ExternalApiFetcher;

impl ContentFetchingService for ExternalApiFetcher {
    fn fetch_content(&self, url: &str) -> Vec<NormalizedData> {
        // Implementation here
        vec![]
    }
}

```

## src/infrastructure/notifications/email_notification_service.rs
```rust
use crate::domain::services::content_delivery_service::ContentDeliveryService;

pub struct EmailNotificationService;

impl ContentDeliveryService for EmailNotificationService {
    
    fn deliver_content(&self, content: &str) -> Result<(), String> {
        // Implementation here
        Ok(())
    }
}

impl EmailNotificationService {
    pub fn new() -> Self {
        EmailNotificationService
    }

    pub fn send_email(&self, to: &str, subject: &str, body: &str) -> Result<(), String> {
        // Implement email sending logic here
        Ok(())
    }
}

```

## src/infrastructure/notifications/mod.rs
```rust
pub mod email_notification_service;

```

## src/infrastructure/repositories/mod.rs
```rust
pub mod sql_content_repository;
```

## src/infrastructure/repositories/sql_content_repository.rs
```rust
use rusqlite::{params, Connection, Result};
use crate::domain::entities::normalized_data::NormalizedData;
use crate::domain::services::content_fetching_service::ContentFetchingService;

pub struct SqlContentRepository;

impl ContentFetchingService for SqlContentRepository {
    fn fetch_content(&self, url: &str) -> Vec<NormalizedData> {
        // Implementation here
        vec![]
    }
}

impl SqlContentRepository {
    pub fn init_db() -> Result<Connection> {
        let conn = Connection::open("data.db")?;
        conn.execute(
            "CREATE TABLE IF NOT EXISTS content (
                id INTEGER PRIMARY KEY,
                source TEXT NOT NULL,
                title TEXT NOT NULL,
                link TEXT NOT NULL,
                description TEXT,
                summary TEXT
            )",
            params![],
        )?;
        Ok(conn)
    }

    pub fn save_content(
        conn: &Connection,
        source: &str,
        title: &str,
        link: &str,
        description: &str,
        summary: &str,
    ) -> Result<()> {
        conn.execute(
            "INSERT INTO content (source, title, link, description, summary) VALUES (?1, ?2, ?3, ?4, ?5)",
            params![source, title, link, description, summary],
        )?;
        Ok(())
    }
}

```

## src/domain/mod.rs
```rust
pub mod entities;
pub mod services;
```

## src/domain/services/mod.rs
```rust
// src/domain/services/mod.rs
pub mod content_fetching_service;
pub mod content_analysis_service;
pub mod content_aggregation_service;
pub mod content_delivery_service;
```

## src/domain/services/content_fetching_service.rs
```rust
use crate::entities::normalized_data::NormalizedData;

pub trait ContentFetchingService {
    fn fetch_content(&self, url: &str) -> Vec<NormalizedData>;
}

```

## src/domain/services/content_aggregation_service.rs
```rust
use serde_json::Value;

pub trait ContentAggregationService {
    fn aggregate_content(&self, data: Vec<Value>) -> Value;
}

```

## src/domain/services/content_analysis_service.rs
```rust
use serde_json::Value;
use crate::entities::normalized_data::NormalizedData;

pub trait ContentAnalysisService {
    fn analyze_content(&self, content: &NormalizedData) -> Result<Value, String>;
}

```

## src/domain/services/content_delivery_service.rs
```rust
pub trait ContentDeliveryService {
    fn deliver_content(&self, content: &str) -> Result<(), String>;
}

```

## src/domain/entities/content.rs
```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct NormalizedData {
    pub title: String,
    pub link: String,
    pub description: String,
}
```

## src/domain/entities/mod.rs
```rust
pub mod normalized_data;
pub mod source_config;
pub mod user_preferences;
```

## src/domain/entities/user_preferences.rs
```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserPreferences {
    pub theme: String,
    pub notifications_enabled: bool,
    pub summary_format: String,
}

```

## src/domain/entities/source_config.rs
```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SourceConfig {
    pub name: String,
    pub source_type: String,
    pub url: String,
    pub prompt: String,
    pub tags: Vec<String>,
}

```

## src/domain/entities/normalized_data.rs
```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct NormalizedData {
    pub title: String,
    pub link: String,
    pub description: String,
}

```

## src/test_utils/mod.rs
```rust
// src/test_utils/mod.rs
pub mod common;

```

## src/test_utils/common.rs
```rust
// // src/test_utils/common.rs
// use crate::config::Settings;

// pub fn load_test_config() -> Settings {
//     Settings::load_from_file("config.test.yml").expect("Failed to load configuration for tests")
// }
```

## src/main.rs
```rust
use structopt::StructOpt;
use env_logger::Env;
use log::info;
use smartcontent_aggregator::config::Settings;
use smartcontent_aggregator::setup::setup_and_run;

#[derive(StructOpt, Debug)]
#[structopt(name = "smartcontent-aggregator")]
struct Opt {
    #[structopt(short, long, default_value = "config.yml")]
    config: String,
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    env_logger::Builder::from_env(Env::default().default_filter_or("debug")).init();

    let opt = Opt::from_args();
    let config = match Settings::load_from_file(&opt.config) {
        Ok(cfg) => cfg,
        Err(e) => {
            eprintln!("Failed to load configuration: {:?}", e);
            std::process::exit(1);
        }
    };
    
    info!("Loaded configuration: {:?}", config);

    setup_and_run(config).await
}

```

## src/lib.rs
```rust
// src/lib.rs
pub mod cli;
pub mod config;
pub mod test_utils;
pub mod domain;
pub mod application;
pub mod infrastructure;
pub mod adapters;
pub mod setup;

pub use test_utils::*;
pub use domain::*;
pub use application::*;
pub use infrastructure::*;
pub use adapters::*;
pub use config::*;
pub use cli::*;
pub use setup::*;
```

## src/adapters/mod.rs
```rust
pub mod primary;
pub mod secondary;
```

## src/adapters/primary/http_content_fetcher.rs
```rust
use crate::domain::entities::normalized_data::NormalizedData;
use crate::domain::services::content_fetching_service::ContentFetchingService;

pub struct HttpContentFetcher;

impl ContentFetchingService for HttpContentFetcher {
    fn fetch_content(&self, url: &str) -> Vec<NormalizedData> {
        // Implementation here
        vec![]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::services::content_fetching_service::ContentFetchingService;
    use crate::domain::entities::normalized_data::NormalizedData;

    #[test]
    fn test_fetch_content() {
        let fetcher = HttpContentFetcher;
//        let result = fetcher.fetch_content("http://example.com");
        // Validate the result
    }
}

```

## src/adapters/primary/mod.rs
```rust
pub mod http_content_fetcher;
pub mod llm_content_analyzer;
pub mod content_aggregator;
pub mod http_content_deliverer;
pub mod scheduler;
pub mod queue;
```

## src/adapters/primary/queue.rs
```rust
use std::sync::{Arc, Mutex};
use tokio::task;
use crate::config::Settings;
use crate::domain::entities::normalized_data::NormalizedData;

lazy_static::lazy_static! {
    static ref ANALYSIS_QUEUE: Mutex<Vec<NormalizedData>> = Mutex::new(Vec::new());
}

pub async fn start_analyzer(config: Arc<Settings>) {
    loop {
        let task = {
            let mut queue = ANALYSIS_QUEUE.lock().unwrap();
            queue.pop()
        };

        if let Some(data) = task {
            let config = config.clone();
            task::spawn(async move {
                // Analyze the data here
                println!("Analyzing data: {:?}", data);
                // Implement the analysis logic here
            });
        } else {
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        }
    }
}

pub fn enqueue_for_analysis(data: NormalizedData) {
    let mut queue = ANALYSIS_QUEUE.lock().unwrap();
    queue.push(data);
}

```

## src/adapters/primary/scheduler.rs
```rust
use std::time::Duration;
use tokio::time::interval;

pub async fn start_scheduler() {
    let mut interval = interval(Duration::from_secs(60)); // Runs every minute

    loop {
        interval.tick().await;
        println!("Scheduler task running...");
        // Add your task logic here
    }
}

```

## src/adapters/primary/http_content_deliverer.rs
```rust
use crate::domain::services::content_delivery_service::ContentDeliveryService;
use actix_web::{web, HttpResponse, Responder, Scope};
pub struct HttpContentDeliverer;

impl ContentDeliveryService for HttpContentDeliverer {
    fn deliver_content(&self, content: &str) -> Result<(), String> {
        // Implementation here
        Ok(())
    }
}

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(web::resource("/deliver")
        .route(web::get().to(deliver_content)));
}

async fn deliver_content() -> impl Responder {
    HttpResponse::Ok().body("Content delivered")
}

```

## src/adapters/primary/content_aggregator.rs
```rust
use serde_json::Value;
use crate::domain::services::content_aggregation_service::ContentAggregationService;

pub struct ContentAggregator;

impl ContentAggregationService for ContentAggregator {
    fn aggregate_content(&self, data: Vec<Value>) -> Value {
        // Implementation here
        Value::Array(data)
    }
}

```

## src/adapters/primary/llm_content_analyzer.rs
```rust
use serde_json::Value;
use crate::domain::entities::normalized_data::NormalizedData;
use crate::domain::services::content_analysis_service::ContentAnalysisService;

pub struct LlmContentAnalyzer;

impl ContentAnalysisService for LlmContentAnalyzer {
    fn analyze_content(&self, content: &NormalizedData) -> Result<Value, String> {
        // Implementation here
        Ok(Value::Null)
    }
}

```

## src/adapters/secondary/mod.rs
```rust
pub mod sql_content_repository;
pub mod file_source_repository;
pub mod external_api_fetcher;
pub mod email_notificaton_service;

```

## src/adapters/secondary/email_notificaton_service.rs
```rust
use crate::domain::services::content_delivery_service::ContentDeliveryService;

pub struct EmailNotificationService;

impl ContentDeliveryService for EmailNotificationService {
    fn deliver_content(&self, content: &str) -> Result<(), String> {
        // Implementation here
        Ok(())
    }
}

```

## src/adapters/secondary/file_source_repository.rs
```rust
// src/adapters/secondary/file_source_repository.rs
use crate::config::Settings;
use std::fs::File;
use std::io::{self, BufReader};
use serde_yaml::from_reader;

pub struct FileSourceRepository;

impl FileSourceRepository {
    pub fn load_sources(filename: &str) -> io::Result<Settings> {
        let file = File::open(filename)?;
        let reader = BufReader::new(file);
        let config: Settings = from_reader(reader).map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?;
        Ok(config)
    }
}

```

## src/adapters/secondary/sql_content_repository.rs
```rust
use crate::domain::entities::normalized_data::NormalizedData;
use crate::domain::services::content_fetching_service::ContentFetchingService;

pub struct SqlContentRepository;

impl ContentFetchingService for SqlContentRepository {
    fn fetch_content(&self, url: &str) -> Vec<NormalizedData> {
        // Implementation here
        vec![]
    }
}

```

## src/adapters/secondary/external_api_fetcher.rs
```rust
use crate::domain::entities::normalized_data::NormalizedData;
use crate::domain::services::content_fetching_service::ContentFetchingService;

pub struct ExternalApiFetcher;

impl ContentFetchingService for ExternalApiFetcher {
    fn fetch_content(&self, url: &str) -> Vec<NormalizedData> {
        // Implementation here
        vec![]
    }
}


```

## src/config/mod.rs
```rust
use serde::{Deserialize, Serialize};
use config::{Config, ConfigError, File, Environment};
use std::fs;
use crate::domain::entities::user_preferences::UserPreferences;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SourceConfig {
    pub name: String,
    pub source_type: String,
    pub url: String,
    pub prompt: String,
    pub tags: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Settings {
    pub llm_type: String,
    pub llm_url: String,
    pub llm_api_key: String,
    pub server: ServerConfig,
    pub sources: Vec<SourceConfig>,
    pub user_preferences: UserPreferences,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let mut builder = Config::builder()
            .add_source(File::with_name("config").required(true))
            .add_source(Environment::with_prefix("APP"));

        if let Ok(env) = std::env::var("APP_ENV") {
            builder = builder.add_source(File::with_name(&format!("config.{}", env)).required(false));
        }

        builder.build()?.try_deserialize()
    }

    pub fn load_from_file(filename: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let content = fs::read_to_string(filename)?;
        let config: Settings = serde_yaml::from_str(&content)?;
        Ok(config)
    }
}
```

## Project Tree
```bash
src
├── adapters
│   ├── mod.rs
│   ├── primary
│   │   ├── content_aggregator.rs
│   │   ├── http_content_deliverer.rs
│   │   ├── http_content_fetcher.rs
│   │   ├── llm_content_analyzer.rs
│   │   ├── mod.rs
│   │   ├── queue.rs
│   │   └── scheduler.rs
│   └── secondary
│       ├── email_notificaton_service.rs
│       ├── external_api_fetcher.rs
│       ├── file_source_repository.rs
│       ├── mod.rs
│       └── sql_content_repository.rs
├── application
│   ├── mod.rs
│   └── use_cases
│       ├── aggregate_content.rs
│       ├── analyze_content.rs
│       ├── deliver_content.rs
│       ├── fetch_content.rs
│       └── mod.rs
├── cli.rs
├── config
│   └── mod.rs
├── domain
│   ├── entities
│   │   ├── content.rs
│   │   ├── mod.rs
│   │   ├── normalized_data.rs
│   │   ├── source_config.rs
│   │   └── user_preferences.rs
│   ├── mod.rs
│   └── services
│       ├── content_aggregation_service.rs
│       ├── content_analysis_service.rs
│       ├── content_delivery_service.rs
│       ├── content_fetching_service.rs
│       └── mod.rs
├── infrastructure
│   ├── external_apis
│   │   ├── external_api_fetcher.rs
│   │   └── mod.rs
│   ├── mod.rs
│   ├── notifications
│   │   ├── email_notification_service.rs
│   │   └── mod.rs
│   └── repositories
│       ├── mod.rs
│       └── sql_content_repository.rs
├── lib.rs
├── main.rs
├── setup
│   ├── http_server.rs
│   ├── mod.rs
│   ├── service_runner.rs
│   └── use_case_initializer.rs
└── test_utils
    ├── common.rs
    └── mod.rs

15 directories, 47 files
```